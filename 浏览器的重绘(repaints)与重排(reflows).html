<html>
<head>
  <title>浏览器的重绘(repaints)与重排(reflows)</title>
  <basefont face="Tahoma" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/274870; Windows/6.3.9600;"/>
  <style>
    body, td {
      font-family: Tahoma;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="686"/>
<h1>浏览器的重绘(repaints)与重排(reflows)</h1>

<div>
<span style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><div><p style="margin: 0px 0px 10px; padding: 0px; color: rgb(85, 85, 85); font-family: &apos;Open Sans&apos;, &apos;Helvetica Neue&apos;, &apos;Hiragino Sans GB&apos;, sans-serif, Arial, Verdana, &apos;BitStream vera Sans&apos;, Tahoma, Helvetica, sans-serif; font-size: 16px; line-height: 27.2000007629395px; text-align: left;">1）浏览器会解析三个东西：</p><ul style="margin: 0px; padding: 0px 0px 10px; color: rgb(85, 85, 85); font-family: &apos;Open Sans&apos;, &apos;Helvetica Neue&apos;, &apos;Hiragino Sans GB&apos;, sans-serif, Arial, Verdana, &apos;BitStream vera Sans&apos;, Tahoma, Helvetica, sans-serif; font-size: 16px; line-height: 27.2000007629395px;"><li style="margin: 0px; padding: 0px 0px 0px 20px; list-style-position: inside;">一个是HTML/SVG/XHTML，事实上，Webkit有三个C++的类对应这三类文档。解析这三种文件会产生一个DOM Tree。</li></ul><ul style="margin: 0px; padding: 0px 0px 10px; color: rgb(85, 85, 85); font-family: &apos;Open Sans&apos;, &apos;Helvetica Neue&apos;, &apos;Hiragino Sans GB&apos;, sans-serif, Arial, Verdana, &apos;BitStream vera Sans&apos;, Tahoma, Helvetica, sans-serif; font-size: 16px; line-height: 27.2000007629395px;"><li style="margin: 0px; padding: 0px 0px 0px 20px; list-style-position: inside;">CSS，解析CSS会产生CSS规则树。</li></ul><ul style="margin: 0px; padding: 0px 0px 10px; color: rgb(85, 85, 85); font-family: &apos;Open Sans&apos;, &apos;Helvetica Neue&apos;, &apos;Hiragino Sans GB&apos;, sans-serif, Arial, Verdana, &apos;BitStream vera Sans&apos;, Tahoma, Helvetica, sans-serif; font-size: 16px; line-height: 27.2000007629395px;"><li style="margin: 0px; padding: 0px 0px 0px 20px; list-style-position: inside;">Javascript，脚本，主要是通过DOM API和CSSOM API来操作DOM Tree和CSS Rule Tree.</li></ul><p style="margin: 0px 0px 10px; padding: 0px; color: rgb(85, 85, 85); font-family: &apos;Open Sans&apos;, &apos;Helvetica Neue&apos;, &apos;Hiragino Sans GB&apos;, sans-serif, Arial, Verdana, &apos;BitStream vera Sans&apos;, Tahoma, Helvetica, sans-serif; font-size: 16px; line-height: 27.2000007629395px;">2）解析完成后，浏览器引擎会通过DOM Tree 和 CSS Rule Tree 来构造 Rendering Tree。注意：</p><ul style="margin: 0px; padding: 0px 0px 10px; color: rgb(85, 85, 85); font-family: &apos;Open Sans&apos;, &apos;Helvetica Neue&apos;, &apos;Hiragino Sans GB&apos;, sans-serif, Arial, Verdana, &apos;BitStream vera Sans&apos;, Tahoma, Helvetica, sans-serif; font-size: 16px; line-height: 27.2000007629395px;"><li style="margin: 0px; padding: 0px 0px 0px 20px; list-style-position: inside;">Rendering Tree 渲染树并不等同于DOM树，因为一些像Header或display:none的东西就没必要放在渲染树中了。</li></ul><ul style="margin: 0px; padding: 0px 0px 10px; color: rgb(85, 85, 85); font-family: &apos;Open Sans&apos;, &apos;Helvetica Neue&apos;, &apos;Hiragino Sans GB&apos;, sans-serif, Arial, Verdana, &apos;BitStream vera Sans&apos;, Tahoma, Helvetica, sans-serif; font-size: 16px; line-height: 27.2000007629395px;"><li style="margin: 0px; padding: 0px 0px 0px 20px; list-style-position: inside;">CSS 的 Rule Tree主要是为了完成匹配并把CSS Rule附加上Rendering Tree上的每个Element。也就是DOM结点。也就是所谓的Frame。</li></ul><ul style="margin: 0px; padding: 0px 0px 10px; color: rgb(85, 85, 85); font-family: &apos;Open Sans&apos;, &apos;Helvetica Neue&apos;, &apos;Hiragino Sans GB&apos;, sans-serif, Arial, Verdana, &apos;BitStream vera Sans&apos;, Tahoma, Helvetica, sans-serif; font-size: 16px; line-height: 27.2000007629395px;"><li style="margin: 0px; padding: 0px 0px 0px 20px; list-style-position: inside;">然后，计算每个Frame（也就是每个Element）的位置，这又叫layout和reflow过程。</li></ul><p style="margin: 0px 0px 10px; padding: 0px; color: rgb(85, 85, 85); font-family: &apos;Open Sans&apos;, &apos;Helvetica Neue&apos;, &apos;Hiragino Sans GB&apos;, sans-serif, Arial, Verdana, &apos;BitStream vera Sans&apos;, Tahoma, Helvetica, sans-serif; font-size: 16px; line-height: 27.2000007629395px;">3）最后通过调用操作系统Native GUI的API绘制。</p></div><div><p style="margin: 0px 0px 10px; padding: 0px; color: rgb(85, 85, 85); font-family: &apos;Open Sans&apos;, &apos;Helvetica Neue&apos;, &apos;Hiragino Sans GB&apos;, sans-serif, Arial, Verdana, &apos;BitStream vera Sans&apos;, Tahoma, Helvetica, sans-serif; font-size: 16px; line-height: 27.2000007629395px;">渲染的流程基本上如下（黄色的四个步骤）：</p><ol style="margin: 0px; padding: 0px 0px 10px; color: rgb(85, 85, 85); font-family: &apos;Open Sans&apos;, &apos;Helvetica Neue&apos;, &apos;Hiragino Sans GB&apos;, sans-serif, Arial, Verdana, &apos;BitStream vera Sans&apos;, Tahoma, Helvetica, sans-serif; font-size: 16px; line-height: 27.2000007629395px;"><li style="margin: 0px; padding: 0px 0px 0px 20px; list-style-position: inside;">计算CSS样式</li><li style="margin: 0px; padding: 0px 0px 0px 20px; list-style-position: inside;">构建Render Tree</li><li style="margin: 0px; padding: 0px 0px 0px 20px; list-style-position: inside;">Layout – 定位坐标和大小，是否换行，各种position, overflow, z-index属性 ……</li><li style="margin: 0px; padding: 0px 0px 0px 20px; list-style-position: inside;">正式开画</li></ol></div><div><br/></div><div><p style="margin: 0px 0px 10px; padding: 0px; color: rgb(85, 85, 85); font-family: &apos;Open Sans&apos;, &apos;Helvetica Neue&apos;, &apos;Hiragino Sans GB&apos;, sans-serif, Arial, Verdana, &apos;BitStream vera Sans&apos;, Tahoma, Helvetica, sans-serif; font-size: 16px; line-height: 27.2000007629395px; text-align: left;">这里重要要说两个概念，一个是Reflow，另一个是Repaint。这两个不是一回事。</p><ul style="margin: 0px; padding: 0px 0px 10px; color: rgb(85, 85, 85); font-family: &apos;Open Sans&apos;, &apos;Helvetica Neue&apos;, &apos;Hiragino Sans GB&apos;, sans-serif, Arial, Verdana, &apos;BitStream vera Sans&apos;, Tahoma, Helvetica, sans-serif; font-size: 16px; line-height: 27.2000007629395px;"><li style="margin: 0px; padding: 0px 0px 0px 20px; list-style-position: inside;">Repaint——屏幕的一部分要重画，比如某个CSS的背景色变了。但是元素的几何尺寸没有变。</li></ul><ul style="margin: 0px; padding: 0px 0px 10px; color: rgb(85, 85, 85); font-family: &apos;Open Sans&apos;, &apos;Helvetica Neue&apos;, &apos;Hiragino Sans GB&apos;, sans-serif, Arial, Verdana, &apos;BitStream vera Sans&apos;, Tahoma, Helvetica, sans-serif; font-size: 16px; line-height: 27.2000007629395px;"><li style="margin: 0px; padding: 0px 0px 0px 20px; list-style-position: inside;">Reflow——意味着元件的几何尺寸变了，我们需要重新验证并计算Render Tree。是Render Tree的一部分或全部发生了变化。这就是Reflow，或是Layout。（<strong>HTML使用的是flow based layout，也就是流式布局，所以，如果某元件的几何尺寸发生了变化，需要重新布局，也就叫reflow</strong>）reflow 会从&lt;html&gt;这个root frame开始递归往下，依次计算所有的结点几何尺寸和位置，在reflow过程中，可能会增加一些frame，比如一个文本字符串必需被包装起来。</li></ul></div><div><br/></div><div><span style="color: rgb(85, 85, 85); font-family: &apos;Open Sans&apos;, &apos;Helvetica Neue&apos;, &apos;Hiragino Sans GB&apos;, sans-serif, Arial, Verdana, &apos;BitStream vera Sans&apos;, Tahoma, Helvetica, sans-serif; font-size: 16px; line-height: 27.2000007629395px; background-color: rgb(255, 255, 255);">Reflow的成本比Repaint的成本高得多的多。DOM Tree里的每个结点都会有reflow方法，一个结点的reflow很有可能导致子结点，甚至父点以及同级结点的reflow。</span><strong style="color: rgb(85, 85, 85); font-family: &apos;Open Sans&apos;, &apos;Helvetica Neue&apos;, &apos;Hiragino Sans GB&apos;, sans-serif, Arial, Verdana, &apos;BitStream vera Sans&apos;, Tahoma, Helvetica, sans-serif; font-size: 16px; line-height: 27.2000007629395px;">在一些高性能的电脑上也许还没什么，但是如果reflow发生在手机上，那么这个过程是非常痛苦和耗电的</strong><span style="color: rgb(85, 85, 85); font-family: &apos;Open Sans&apos;, &apos;Helvetica Neue&apos;, &apos;Hiragino Sans GB&apos;, sans-serif, Arial, Verdana, &apos;BitStream vera Sans&apos;, Tahoma, Helvetica, sans-serif; font-size: 16px; line-height: 27.2000007629395px; background-color: rgb(255, 255, 255);">。</span><p style="margin: 0px 0px 10px; padding: 0px; color: rgb(85, 85, 85); font-family: &apos;Open Sans&apos;, &apos;Helvetica Neue&apos;, &apos;Hiragino Sans GB&apos;, sans-serif, Arial, Verdana, &apos;BitStream vera Sans&apos;, Tahoma, Helvetica, sans-serif; font-size: 16px; line-height: 27.2000007629395px;"></p><p style="margin: 0px 0px 10px; padding: 0px; color: rgb(85, 85, 85); font-family: &apos;Open Sans&apos;, &apos;Helvetica Neue&apos;, &apos;Hiragino Sans GB&apos;, sans-serif, Arial, Verdana, &apos;BitStream vera Sans&apos;, Tahoma, Helvetica, sans-serif; font-size: 16px; line-height: 27.2000007629395px;">所以，下面这些动作有很大可能会是成本比较高的。</p><ul style="margin: 0px; padding: 0px 0px 10px; color: rgb(85, 85, 85); font-family: &apos;Open Sans&apos;, &apos;Helvetica Neue&apos;, &apos;Hiragino Sans GB&apos;, sans-serif, Arial, Verdana, &apos;BitStream vera Sans&apos;, Tahoma, Helvetica, sans-serif; font-size: 16px; line-height: 27.2000007629395px;"><li style="margin: 0px; padding: 0px 0px 0px 20px; list-style-position: inside;">当你增加、删除、修改DOM结点时，会导致Reflow或Repaint</li><li style="margin: 0px; padding: 0px 0px 0px 20px; list-style-position: inside;">当你移动DOM的位置，或是搞个动画的时候。</li><li style="margin: 0px; padding: 0px 0px 0px 20px; list-style-position: inside;">当你修改CSS样式的时候。</li><li style="margin: 0px; padding: 0px 0px 0px 20px; list-style-position: inside;">当你Resize窗口的时候（移动端没有这个问题），或是滚动的时候。</li><li style="margin: 0px; padding: 0px 0px 0px 20px; list-style-position: inside;">当你修改网页的默认字体时。</li></ul><p style="margin: 0px 0px 10px; padding: 0px; color: rgb(85, 85, 85); font-family: &apos;Open Sans&apos;, &apos;Helvetica Neue&apos;, &apos;Hiragino Sans GB&apos;, sans-serif, Arial, Verdana, &apos;BitStream vera Sans&apos;, Tahoma, Helvetica, sans-serif; font-size: 16px; line-height: 27.2000007629395px; text-align: left;">注：display:none会触发reflow，而visibility:hidden只会触发repaint，因为没有发现位置变化。</p><p style="margin: 0px 0px 10px; padding: 0px; color: rgb(85, 85, 85); font-family: &apos;Open Sans&apos;, &apos;Helvetica Neue&apos;, &apos;Hiragino Sans GB&apos;, sans-serif, Arial, Verdana, &apos;BitStream vera Sans&apos;, Tahoma, Helvetica, sans-serif; font-size: 16px; line-height: 27.2000007629395px; text-align: left;">多说两句关于滚屏的事，通常来说，如果在滚屏的时候，我们的页面上的所有的像素都会跟着滚动，那么性能上没什么问题，因为我们的显卡对于这种把全屏像素往上往下移的算法是很快。但是如果你有一个fixed的背景图，或是有些Element不跟着滚动，有些Elment是动画，那么这个滚动的动作对于浏览器来说会是相当相当痛苦的一个过程。你可以看到很多这样的网页在滚动的时候性能有多差。因为滚屏也有可能会造成reflow。</p><p style="margin: 0px 0px 10px; padding: 0px; color: rgb(85, 85, 85); font-family: &apos;Open Sans&apos;, &apos;Helvetica Neue&apos;, &apos;Hiragino Sans GB&apos;, sans-serif, Arial, Verdana, &apos;BitStream vera Sans&apos;, Tahoma, Helvetica, sans-serif; font-size: 16px; line-height: 27.2000007629395px; text-align: left;">基本上来说，reflow有如下的几个原因：</p><ul style="margin: 0px; padding: 0px 0px 10px; color: rgb(85, 85, 85); font-family: &apos;Open Sans&apos;, &apos;Helvetica Neue&apos;, &apos;Hiragino Sans GB&apos;, sans-serif, Arial, Verdana, &apos;BitStream vera Sans&apos;, Tahoma, Helvetica, sans-serif; font-size: 16px; line-height: 27.2000007629395px;"><li style="margin: 0px; padding: 0px 0px 0px 20px; list-style-position: inside;">Initial。网页初始化的时候。</li><li style="margin: 0px; padding: 0px 0px 0px 20px; list-style-position: inside;">Incremental。一些Javascript在操作DOM Tree时。</li><li style="margin: 0px; padding: 0px 0px 0px 20px; list-style-position: inside;">Resize。其些元件的尺寸变了。</li><li style="margin: 0px; padding: 0px 0px 0px 20px; list-style-position: inside;">StyleChange。如果CSS的属性发生变化了。</li><li style="margin: 0px; padding: 0px 0px 0px 20px; list-style-position: inside;">Dirty。几个Incremental的reflow发生在同一个frame的子树上。</li></ul></div><div><h4 style="margin: 40px 0px 10px; padding: 10px 0px 10px 10px; font-family: &apos;Microsoft YaHei&apos;, Arial; font-size: 21px; color: rgb(0, 136, 0); border-left-color: green; border-left-style: solid; border-left-width: thick; text-align: left; background-color: rgb(248, 248, 248);">减少reflow/repaint</h4></div><div>     <strong style="color: rgb(85, 85, 85); font-family: &apos;Open Sans&apos;, &apos;Helvetica Neue&apos;, &apos;Hiragino Sans GB&apos;, sans-serif, Arial, Verdana, &apos;BitStream vera Sans&apos;, Tahoma, Helvetica, sans-serif; font-size: 16px; line-height: 27.2000007629395px; background-color: rgb(255, 255, 255);">1）不要一条一条地修改DOM的样式。与其这样，还不如预先定义好css的class，然后修改DOM的className。</strong></div><div><strong style="color: rgb(85, 85, 85); font-family: &apos;Open Sans&apos;, &apos;Helvetica Neue&apos;, &apos;Hiragino Sans GB&apos;, sans-serif, Arial, Verdana, &apos;BitStream vera Sans&apos;, Tahoma, Helvetica, sans-serif; font-size: 16px; line-height: 27.2000007629395px; background-color: rgb(255, 255, 255);">2）把DOM离线后修改。</strong></div><div><ul style="margin: 0px; padding: 0px 0px 10px; color: rgb(85, 85, 85); font-family: &apos;Open Sans&apos;, &apos;Helvetica Neue&apos;, &apos;Hiragino Sans GB&apos;, sans-serif, Arial, Verdana, &apos;BitStream vera Sans&apos;, Tahoma, Helvetica, sans-serif; font-size: 16px; line-height: 27.2000007629395px;"><li style="margin: 0px; padding: 0px 0px 0px 20px; list-style-position: inside;">使用documentFragment 对象在内存里操作DOM</li><li style="margin: 0px; padding: 0px 0px 0px 20px; list-style-position: inside;">先把DOM给display:none(有一次reflow)，然后你想怎么改就怎么改。比如修改100次，然后再把他显示出来。</li><li style="margin: 0px; padding: 0px 0px 0px 20px; list-style-position: inside;">clone一个DOM结点到内存里，然后想怎么改就怎么改，改完后，和在线的那个的交换一下。</li></ul><div><p style="margin: 0px 0px 10px; padding: 0px; color: rgb(85, 85, 85); font-family: &apos;Open Sans&apos;, &apos;Helvetica Neue&apos;, &apos;Hiragino Sans GB&apos;, sans-serif, Arial, Verdana, &apos;BitStream vera Sans&apos;, Tahoma, Helvetica, sans-serif; font-size: 16px; line-height: 27.2000007629395px;">3）<strong>不要把DOM结点的属性值放在一个循环里当成循环里的变量。</strong>不然这会导致大量地读写这个结点的属性。</p><p style="margin: 0px 0px 10px; padding: 0px; color: rgb(85, 85, 85); font-family: &apos;Open Sans&apos;, &apos;Helvetica Neue&apos;, &apos;Hiragino Sans GB&apos;, sans-serif, Arial, Verdana, &apos;BitStream vera Sans&apos;, Tahoma, Helvetica, sans-serif; font-size: 16px; line-height: 27.2000007629395px;">4）<strong>尽可能的修改层级比较低的DOM</strong>。当然，改变层级比较底的DOM有可能会造成大面积的reflow，但是也可能影响范围很小。</p><p style="margin: 0px 0px 10px; padding: 0px; color: rgb(85, 85, 85); font-family: &apos;Open Sans&apos;, &apos;Helvetica Neue&apos;, &apos;Hiragino Sans GB&apos;, sans-serif, Arial, Verdana, &apos;BitStream vera Sans&apos;, Tahoma, Helvetica, sans-serif; font-size: 16px; line-height: 27.2000007629395px;">5）<strong>为动画的HTML元件使用fixed或absoult的position</strong>，那么修改他们的CSS是不会reflow的。</p><p style="margin: 0px 0px 10px; padding: 0px; color: rgb(85, 85, 85); font-family: &apos;Open Sans&apos;, &apos;Helvetica Neue&apos;, &apos;Hiragino Sans GB&apos;, sans-serif, Arial, Verdana, &apos;BitStream vera Sans&apos;, Tahoma, Helvetica, sans-serif; font-size: 16px; line-height: 27.2000007629395px;">6）<strong>千万不要使用table布局</strong>。因为可能很小的一个小改动会造成整个table的重新布局。</p></div></div><div><font color="#555555" face="Open Sans, Helvetica Neue, Hiragino Sans GB, sans-serif, Arial, Verdana, BitStream vera Sans, Tahoma, Helvetica, sans-serif"><span style="line-height: 27px;"><br/></span></font></div><div><font color="#555555" face="Open Sans, Helvetica Neue, Hiragino Sans GB, sans-serif, Arial, Verdana, BitStream vera Sans, Tahoma, Helvetica, sans-serif"><span style="line-height: 27px;"><br/></span></font></div><div><font color="#555555" face="Open Sans, Helvetica Neue, Hiragino Sans GB, sans-serif, Arial, Verdana, BitStream vera Sans, Tahoma, Helvetica, sans-serif"><span style="line-height: 27px;"><br/></span></font></div><div><font color="#555555" face="Open Sans, Helvetica Neue, Hiragino Sans GB, sans-serif, Arial, Verdana, BitStream vera Sans, Tahoma, Helvetica, sans-serif"><span style="line-height: 27px;"><br/></span></font></div><div><font color="#555555" face="Open Sans, Helvetica Neue, Hiragino Sans GB, sans-serif, Arial, Verdana, BitStream vera Sans, Tahoma, Helvetica, sans-serif"><span style="line-height: 27px;"><br/></span></font></div><div><br/></div><div>浏览器从下载文档到显示页面的过程是个复杂的过程，这里包含了重绘和重排。各家浏览器引擎的工作原理略有差 别，但也有一定规则。简单讲，通常在文档初次加载时，浏览器引擎会解析HTML文档来构建DOM树，之后根据DOM元素的几何属性构建一棵用于渲染的树。 渲染树的每个节点都有大小和边距等属性，类似于盒子模型（由于隐藏元素不需要显示，渲染树中并不包含DOM树中隐藏的元素）。当渲染树构建完成后，浏览器 就可以将元素放置到正确的位置了，再根据渲染树节点的样式属性绘制出页面。由于浏览器的流布局，对渲染树的计算通常只需要遍历一次就可以完成。但 table及其内部元素除外，它可能需要多次计算才能确定好其在渲染树中节点的属性，通常要花3倍于同等元素的时间。这也是为什么我们要避免使用 table做布局的一个原因。</div><p style="margin: 0px 0px 1.5em; padding: 0px; border: 0px; font-family: &amp;amp;amp;apos;PT Serif&amp;amp;amp;apos;; font-size: 16px; font-stretch: inherit; line-height: 24px; vertical-align: baseline; color: rgb(31, 9, 9); text-align: left;">重绘是一个元素外观的改变所触发的浏览器行为，例如改变vidibility、outline、背景色等属性。浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。重绘不会带来重新布局，并不一定伴随重排。</p><p style="margin: 0px 0px 1.5em; padding: 0px; border: 0px; font-family: &amp;amp;amp;apos;PT Serif&amp;amp;amp;apos;; font-size: 16px; font-stretch: inherit; line-height: 24px; vertical-align: baseline; color: rgb(31, 9, 9); text-align: left;">重排是更明显的一种改变，可以理解为渲染树需要重新计算。下面是常见的触发重排的操作：</p><p style="margin: 0px 0px 1.5em; padding: 0px; border: 0px; font-family: &amp;amp;amp;apos;PT Serif&amp;amp;amp;apos;; font-size: 16px; font-stretch: inherit; line-height: 24px; vertical-align: baseline; color: rgb(31, 9, 9); text-align: left;"><strong style="margin: 0px; padding: 0px; border: 0px; font-family: inherit; font-size: inherit; font-style: inherit; font-variant: inherit; font-stretch: inherit; line-height: inherit; vertical-align: baseline;">1. DOM元素的几何属性变化</strong></p><p style="margin: 0px 0px 1.5em; padding: 0px; border: 0px; font-family: &amp;amp;amp;apos;PT Serif&amp;amp;amp;apos;; font-size: 16px; font-stretch: inherit; line-height: 24px; vertical-align: baseline; color: rgb(31, 9, 9); text-align: left;">当DOM元素的几何属性变化时，渲染树中的相关节点就会失效，浏览器会根据DOM元素的变化重建构建渲染树中失效的节点。之后，会根据新的渲染树重新绘 制这部分页面。而且，当前元素的重排也许会带来相关元素的重排。例如，容器节点的渲染树改变时，会触发子节点的重新计算，也会触发其后续兄弟节点的重排， 祖先节点需要重新计算子节点的尺寸也会产生重排。最后，每个元素都将发生重绘。可见，重排一定会引起浏览器的重绘，一个元素的重排通常会带来一系列的反 应，甚至触发整个文档的重排和重绘，性能代价是高昂的。</p><p style="margin: 0px 0px 1.5em; padding: 0px; border: 0px; font-family: &amp;amp;amp;apos;PT Serif&amp;amp;amp;apos;; font-size: 16px; font-stretch: inherit; line-height: 24px; vertical-align: baseline; color: rgb(31, 9, 9); text-align: left;"><strong style="margin: 0px; padding: 0px; border: 0px; font-family: inherit; font-size: inherit; font-style: inherit; font-variant: inherit; font-stretch: inherit; line-height: inherit; vertical-align: baseline;">2.DOM树的结构变化</strong></p><p style="margin: 0px 0px 1.5em; padding: 0px; border: 0px; font-family: &amp;amp;amp;apos;PT Serif&amp;amp;amp;apos;; font-size: 16px; font-stretch: inherit; line-height: 24px; vertical-align: baseline; color: rgb(31, 9, 9); text-align: left;">当DOM树的 结构变化时，例如节点的增减、移动等，也会触发重排。浏览器引擎布局的过程，类似于树的前序遍历，是一个从上到下从左到右的过程。通常在这个过程中，当前 元素不会再影响其前面已经遍历过的元素。所以，如果在body最前面插入一个元素，会导致整个文档的重新渲染，而在其后插入一个元素，则不会影响到前面的 元素。</p><p style="margin: 0px 0px 1.5em; padding: 0px; border: 0px; font-family: &amp;amp;amp;apos;PT Serif&amp;amp;amp;apos;; font-size: 16px; font-stretch: inherit; line-height: 24px; vertical-align: baseline; color: rgb(31, 9, 9); text-align: left;"><strong style="margin: 0px; padding: 0px; border: 0px; font-family: inherit; font-size: inherit; font-style: inherit; font-variant: inherit; font-stretch: inherit; line-height: inherit; vertical-align: baseline;">3.获取某些属性</strong></p><p style="margin: 0px 0px 1.5em; padding: 0px; border: 0px; font-family: &amp;amp;amp;apos;PT Serif&amp;amp;amp;apos;; font-size: 16px; font-stretch: inherit; line-height: 24px; vertical-align: baseline; color: rgb(31, 9, 9); text-align: left;">浏览器引擎可能会针对重排做了优化。比如Opera，它会等到有足够 数量的变化发生，或者等到一定的时间，或者等一个线程结束，再一起处理，这样就只发生一次重排。但除了渲染树的直接变化，当获取一些属性时，浏览器为取得 正确的值也会触发重排。这样就使得浏览器的优化失效了。这些属性包括：offsetTop、offsetLeft、 offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、 clientTop、clientLeft、clientWidth、clientHeight、getComputedStyle() (currentStyle in IE)。所以，在多次使用这些值时应进行缓存。</p><p style="margin: 0px 0px 1.5em; padding: 0px; border: 0px; font-family: &amp;amp;amp;apos;PT Serif&amp;amp;amp;apos;; font-size: 16px; font-stretch: inherit; line-height: 24px; vertical-align: baseline; color: rgb(31, 9, 9); text-align: left;">此外，改变元素的一些样式，调整浏览器窗口大小等等也都将触发重排。</p><p style="margin: 0px 0px 1.5em; padding: 0px; border: 0px; font-family: &amp;amp;amp;apos;PT Serif&amp;amp;amp;apos;; font-size: 16px; font-stretch: inherit; line-height: 24px; vertical-align: baseline; color: rgb(31, 9, 9); text-align: left;">开发中，比较好的实践是尽量减少重排次数和缩小重排的影响范围。例如：</p><p style="margin: 0px 0px 1.5em; padding: 0px; border: 0px; font-family: &amp;amp;amp;apos;PT Serif&amp;amp;amp;apos;; font-size: 16px; font-stretch: inherit; line-height: 24px; vertical-align: baseline; color: rgb(31, 9, 9); text-align: left;">1. 将多次改变样式属性的操作合并成一次操作。例如，</p><pre style="margin-top: 0px; margin-bottom: 0px; padding: 0px; border: 0px; font-family: Inconsolata; font-size: 0.875em; font-stretch: inherit; line-height: 1.714285em; vertical-align: baseline; width: auto; color: rgb(31, 9, 9); text-align: left; background-color: rgb(243, 242, 238);"></pre><ol style="margin: 0px 0px 1.5em 1.5em; padding: 0px; border: 0px; font-family: inherit; font-size: inherit; font-style: inherit; font-variant: inherit; font-stretch: inherit; line-height: inherit; vertical-align: baseline; list-style: none;"><li style="margin: 0px; padding: 0px; border: 0px; font-family: inherit; font-size: inherit; font-style: inherit; font-variant: inherit; font-stretch: inherit; line-height: inherit; vertical-align: baseline; list-style: decimal outside;"><p style="margin: 0px; padding: 0px; border: 0px; font-family: inherit; font-size: inherit; font-style: inherit; font-variant: inherit; font-stretch: inherit; line-height: inherit; vertical-align: baseline;">changeDiv documentgetElementById'changeDiv'</p></li><li style="margin: 0px; padding: 0px; border: 0px; font-family: inherit; font-size: inherit; font-style: inherit; font-variant: inherit; font-stretch: inherit; line-height: inherit; vertical-align: baseline; list-style: decimal outside;"><p style="margin: 0px; padding: 0px; border: 0px; font-family: inherit; font-size: inherit; font-style: inherit; font-variant: inherit; font-stretch: inherit; line-height: inherit; vertical-align: baseline;">changeDivstylecolor '#093'</p></li><li style="margin: 0px; padding: 0px; border: 0px; font-family: inherit; font-size: inherit; font-style: inherit; font-variant: inherit; font-stretch: inherit; line-height: inherit; vertical-align: baseline; list-style: decimal outside;"><p style="margin: 0px; padding: 0px; border: 0px; font-family: inherit; font-size: inherit; font-style: inherit; font-variant: inherit; font-stretch: inherit; line-height: inherit; vertical-align: baseline;">changeDivstylebackground '#eee'</p></li><li style="margin: 0px; padding: 0px; border: 0px; font-family: inherit; font-size: inherit; font-style: inherit; font-variant: inherit; font-stretch: inherit; line-height: inherit; vertical-align: baseline; list-style: decimal outside;"><p style="margin: 0px; padding: 0px; border: 0px; font-family: inherit; font-size: inherit; font-style: inherit; font-variant: inherit; font-stretch: inherit; line-height: inherit; vertical-align: baseline;">changeDivstyleheight '200px'</p></li></ol><p style="margin: 0px 0px 1.5em; padding: 0px; border: 0px; font-family: &amp;amp;amp;apos;PT Serif&amp;amp;amp;apos;; font-size: 16px; font-stretch: inherit; line-height: 24px; vertical-align: baseline; color: rgb(31, 9, 9); text-align: left;">可以合并为：</p><pre style="margin-top: 0px; margin-bottom: 0px; padding: 0px; border: 0px; font-family: Inconsolata; font-size: 0.875em; font-stretch: inherit; line-height: 1.714285em; vertical-align: baseline; width: auto; color: rgb(31, 9, 9); text-align: left; background-color: rgb(243, 242, 238);"></pre><ol style="margin: 0px 0px 1.5em 1.5em; padding: 0px; border: 0px; font-family: inherit; font-size: inherit; font-style: inherit; font-variant: inherit; font-stretch: inherit; line-height: inherit; vertical-align: baseline; list-style: none;"><li style="margin: 0px; padding: 0px; border: 0px; font-family: inherit; font-size: inherit; font-style: inherit; font-variant: inherit; font-stretch: inherit; line-height: inherit; vertical-align: baseline; list-style: decimal outside;"><p style="margin: 0px; padding: 0px; border: 0px; font-family: inherit; font-size: inherit; font-style: inherit; font-variant: inherit; font-stretch: inherit; line-height: inherit; vertical-align: baseline;">changeDiv</p></li><li style="margin: 0px; padding: 0px; border: 0px; font-family: inherit; font-size: inherit; font-style: inherit; font-variant: inherit; font-stretch: inherit; line-height: inherit; vertical-align: baseline; list-style: decimal outside;"><p style="margin: 0px; padding: 0px; border: 0px; font-family: inherit; font-size: inherit; font-style: inherit; font-variant: inherit; font-stretch: inherit; line-height: inherit; vertical-align: baseline;">background#eee;</p></li><li style="margin: 0px; padding: 0px; border: 0px; font-family: inherit; font-size: inherit; font-style: inherit; font-variant: inherit; font-stretch: inherit; line-height: inherit; vertical-align: baseline; list-style: decimal outside;"><p style="margin: 0px; padding: 0px; border: 0px; font-family: inherit; font-size: inherit; font-style: inherit; font-variant: inherit; font-stretch: inherit; line-height: inherit; vertical-align: baseline;">color#093;</p></li><li style="margin: 0px; padding: 0px; border: 0px; font-family: inherit; font-size: inherit; font-style: inherit; font-variant: inherit; font-stretch: inherit; line-height: inherit; vertical-align: baseline; list-style: decimal outside;"><p style="margin: 0px; padding: 0px; border: 0px; font-family: inherit; font-size: inherit; font-style: inherit; font-variant: inherit; font-stretch: inherit; line-height: inherit; vertical-align: baseline;">height200px</p></li></ol><pre style="margin-top: 0px; margin-bottom: 0px; padding: 0px; border: 0px; font-family: Inconsolata; font-size: 0.875em; font-stretch: inherit; line-height: 1.714285em; vertical-align: baseline; width: auto; color: rgb(31, 9, 9); text-align: left; background-color: rgb(243, 242, 238);"></pre><ol style="margin: 0px 0px 1.5em 1.5em; padding: 0px; border: 0px; font-family: inherit; font-size: inherit; font-style: inherit; font-variant: inherit; font-stretch: inherit; line-height: inherit; vertical-align: baseline; list-style: none;"><li style="margin: 0px; padding: 0px; border: 0px; font-family: inherit; font-size: inherit; font-style: inherit; font-variant: inherit; font-stretch: inherit; line-height: inherit; vertical-align: baseline; list-style: decimal outside;"><p style="margin: 0px; padding: 0px; border: 0px; font-family: inherit; font-size: inherit; font-style: inherit; font-variant: inherit; font-stretch: inherit; line-height: inherit; vertical-align: baseline;">documentgetElementById'changeDiv'className 'changeDiv'</p></li></ol><p style="margin: 0px 0px 1.5em; padding: 0px; border: 0px; font-family: &amp;amp;amp;apos;PT Serif&amp;amp;amp;apos;; font-size: 16px; font-stretch: inherit; line-height: 24px; vertical-align: baseline; color: rgb(31, 9, 9); text-align: left;">2. 将需要多次重排的元素，position属性设为absolute或fixed，这样此元素就脱离了文档流，它的变化不会影响到其他元素。例如有动画效果的元素就最好设置为绝对定位。</p><p style="margin: 0px 0px 1.5em; padding: 0px; border: 0px; font-family: &amp;amp;amp;apos;PT Serif&amp;amp;amp;apos;; font-size: 16px; font-stretch: inherit; line-height: 24px; vertical-align: baseline; color: rgb(31, 9, 9); text-align: left;">3. 在内存中多次操作节点，完成后再添加到文档中去。例如要异步获取表格数据，渲染到页面。可以先取得数据后在内存中构建整个表格的html片段，再一次性添加到文档中去，而不是循环添加每一行。</p><p style="margin: 0px 0px 1.5em; padding: 0px; border: 0px; font-family: &amp;amp;amp;apos;PT Serif&amp;amp;amp;apos;; font-size: 16px; font-stretch: inherit; line-height: 24px; vertical-align: baseline; color: rgb(31, 9, 9); text-align: left;">4. 由于display属性为none的元素不在渲染树中，对隐藏的元素操作不会引发其他元素的重排。如果要对一个元素进行复杂的操作时，可以先隐藏它，操作完成后再显示。这样只在隐藏和显示时触发2次重排。</p><p style="margin: 0px 0px 1.5em; padding: 0px; border: 0px; font-family: &amp;amp;amp;apos;PT Serif&amp;amp;amp;apos;; font-size: 16px; font-stretch: inherit; line-height: 24px; vertical-align: baseline; color: rgb(31, 9, 9); text-align: left;">5. 在需要经常取那些引起浏览器重排的属性值时，要缓存到变量。</p><p style="margin: 0px 0px 1.5em; padding: 0px; border: 0px; font-family: &amp;amp;amp;apos;PT Serif&amp;amp;amp;apos;; font-size: 16px; font-stretch: inherit; line-height: 24px; vertical-align: baseline; color: rgb(31, 9, 9); text-align: left;"></p><div><h2 style="margin: 1.75em 0px 0.75em; padding: 0px; border: 0px; font: inherit; vertical-align: baseline; line-height: 1.75em; font-family: Helvetica, Arial; color: rgb(68, 68, 68); text-align: -webkit-auto; background-color: rgb(255, 255, 255);">1、减少reflow</h2><h3 style="margin: 2em 0px 0.75em; padding: 0px; border: 0px; font: inherit; vertical-align: baseline; font-family: Helvetica, Arial; color: rgb(68, 68, 68); line-height: 21px; text-align: -webkit-auto; background-color: rgb(255, 255, 255);">什么是reflow？</h3><blockquote style="margin: 0px 0px 1.5em 2em; padding: 0px 0px 0px 1em; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 5px; border-left-style: solid; border-top-color: rgb(209, 209, 209); border-right-color: rgb(209, 209, 209); border-bottom-color: rgb(209, 209, 209); border-left-color: rgb(209, 209, 209); font: inherit; vertical-align: baseline; quotes: none; font-style: italic; color: rgb(51, 51, 51); font-family: Helvetica, Arial; line-height: 21px; text-align: -webkit-auto; background-color: rgb(255, 255, 255);"><p style="margin: 0px 0px 1.5em; padding: 0px; border: 0px; font-size: 14px; font: inherit; vertical-align: baseline;">当 DOM 元素的属性发生变化 (如 color) 时, 浏览器会通知 render 重新描绘相应的元素, 此过程称为 repaint。</p><p style="margin: 0px 0px 1.5em; padding: 0px; border: 0px; font-size: 14px; font: inherit; vertical-align: baseline;">如果该次变化涉及元素布局 (如 width), 浏览器则抛弃原有属性, 重新计算并把结果传递给 render 以重新描绘页面元素, 此过程称为 reflow。</p></blockquote><h3 style="margin: 2em 0px 0.75em; padding: 0px; border: 0px; font: inherit; vertical-align: baseline; font-family: Helvetica, Arial; color: rgb(68, 68, 68); line-height: 21px; text-align: -webkit-auto; background-color: rgb(255, 255, 255);">减少reflow的方法</h3><ol style="margin: 0.5em 0px 1.5em 1em; padding: 0px; border: 0px; font: inherit; vertical-align: baseline; list-style: none; color: rgb(51, 51, 51); font-family: Helvetica, Arial; line-height: 21px; text-align: -webkit-auto; background-color: rgb(255, 255, 255);"><li style="margin: 0px; padding: 0px; border: 0px; font-size: 14px; font: inherit; vertical-align: baseline; list-style: decimal inside;">先将元素从document中删除，完成修改后再把元素放回原来的位置（当对某元素及其子元素进行大量reflow操作时，1,2两种方法效果才会比较明显）</li><li style="margin: 0px; padding: 0px; border: 0px; font-size: 14px; font: inherit; vertical-align: baseline; list-style: decimal inside;">将元素的display设置为”none”，完成修改后再把display修改为原来的值</li><li style="margin: 0px; padding: 0px; border: 0px; font-size: 14px; font: inherit; vertical-align: baseline; list-style: decimal inside;">修改多个样式属性时定义class类代替多次修改style属性（for certain同学推荐）</li><li style="margin: 0px; padding: 0px; border: 0px; font-size: 14px; font: inherit; vertical-align: baseline; list-style: decimal inside;">大量添加元素到页面时使用documentFragment</li></ol><div style="margin: 0px 0px 1.5em; padding: 0px; border: 0px; font: inherit; vertical-align: baseline; color: rgb(51, 51, 51); font-family: Helvetica, Arial; line-height: 21px; text-align: -webkit-auto; background-color: rgb(255, 255, 255);"><pre style="margin-top: 0px; margin-bottom: 0px; padding: 0px; border: 0px; font: inherit; vertical-align: baseline; line-height: 1.75em;">
for(var i=0;i&lt;100:i++){
    var child = docuemnt.createElement(&quot;li&quot;);
    child.innerHtml = &quot;child&quot;;
    document.getElementById(&quot;parent&quot;).appendChild(child);
}
</pre></div><p style="margin: 0px 0px 1.5em; padding: 0px; border: 0px; font: inherit; vertical-align: baseline; color: rgb(51, 51, 51); font-family: Helvetica, Arial; line-height: 21px; text-align: -webkit-auto; background-color: rgb(255, 255, 255);">上述代码会多次操作dom，效率比较低，可以改为下面的形式 创建documentFragment，将所有元素加入到docuemntFragment不会改变dom结构，最后将其添加到页面，只进行了一次reflow</p><div style="margin: 0px 0px 1.5em; padding: 0px; border: 0px; font: inherit; vertical-align: baseline; color: rgb(51, 51, 51); font-family: Helvetica, Arial; line-height: 21px; text-align: -webkit-auto; background-color: rgb(255, 255, 255);"><pre style="margin-top: 0px; margin-bottom: 0px; padding: 0px; border: 0px; font: inherit; vertical-align: baseline; line-height: 1.75em;">
var frag = document.createDocumentFragment();
for(var i=0;i&lt;100:i++){
        var child = docuemnt.createElement(&quot;li&quot;);
        child.innerHtml = &quot;child&quot;;
    frag.appendChild(child);
}
document.getElementById(&quot;parent&quot;).appendChild(frag);
</pre><pre style="margin-top: 0px; margin-bottom: 0px; padding: 0px; border: 0px; font: inherit; vertical-align: baseline; line-height: 1.75em;"><br/></pre><pre style="margin-top: 0px; margin-bottom: 0px; padding: 0px; border: 0px; font: inherit; vertical-align: baseline; line-height: 1.75em;"></pre><div><h2 style="margin: 1.75em 0px 0.75em; padding: 0px; border: 0px; font: inherit; vertical-align: baseline; line-height: 1.75em; color: rgb(68, 68, 68); white-space: normal;">4、使用事件委托</h2><p style="margin: 0px 0px 1.5em; padding: 0px; border: 0px; font: inherit; vertical-align: baseline; line-height: 21px; white-space: normal;"><strong style="margin: 0px; padding: 0px; border: 0px; font: inherit; vertical-align: baseline;">使用场景：</strong>一个有大量记录的列表，每条记录都需要绑定点击事件，在鼠标点击后实现某些功能，我们通常的做法是给每条记录都绑定监听事件，这种做法会导致页面会有大量的事件监听器，效率比较低下。</p><p style="margin: 0px 0px 1.5em; padding: 0px; border: 0px; font: inherit; vertical-align: baseline; line-height: 21px; white-space: normal;"><strong style="margin: 0px; padding: 0px; border: 0px; font: inherit; vertical-align: baseline;">基本原理：</strong>我们都知道dom规范中事件是会冒泡的，也就是说在不主动阻止事件冒泡的情况下任何一个元素的事件都会按照dom树的结构逐级冒泡至顶端。而event对象中也提供了event.target（IE下是srcElement）指向事件源，因此我们即使在父级元素上监听该事件也可以找到触发该事件的最原始的元素，这就是委托的基本原理。废话不多说，上示例</p><div style="margin: 0px 0px 1.5em; padding: 0px; border: 0px; font: inherit; vertical-align: baseline; line-height: 21px; white-space: normal;"><pre style="margin-top: 0px; margin-bottom: 0px; padding: 0px; border: 0px; font: inherit; vertical-align: baseline; line-height: 1.75em;">
$(&quot;ul li&quot;).bind(&quot;click&quot;,function(){
    alert($(this).attr(&quot;data&quot;));
})
</pre></div><p style="margin: 0px 0px 1.5em; padding: 0px; border: 0px; font: inherit; vertical-align: baseline; line-height: 21px; white-space: normal;">上述写法其实是给所有的li元素都绑定了click事件来监听鼠标点击每一个元素的事件，这样页面上会有大量的事件监听器。</p><p style="margin: 0px 0px 1.5em; padding: 0px; border: 0px; font: inherit; vertical-align: baseline; line-height: 21px; white-space: normal;">根据上面介绍的监听事件的原理我们来改写一下</p><div style="margin: 0px 0px 1.5em; padding: 0px; border: 0px; font: inherit; vertical-align: baseline; line-height: 21px; white-space: normal;"><pre style="margin-top: 0px; margin-bottom: 0px; padding: 0px; border: 0px; font: inherit; vertical-align: baseline; line-height: 1.75em;">
$(&quot;ul&quot;).bind(&quot;click&quot;,function(e){
    if(e.target.nodeName.toLowerCase() ===&quot;li&quot;){
        alert($(e.target).attr(&quot;data&quot;));
    }
})
</pre></div><p style="margin: 0px 0px 1.5em; padding: 0px; border: 0px; font: inherit; vertical-align: baseline; line-height: 21px; white-space: normal;">这样一来，我们就可以只添加一个事件监听器去捕获所有li上触发的事件，并做出相应的操作。</p><p style="margin: 0px 0px 1.5em; padding: 0px; border: 0px; font: inherit; vertical-align: baseline; line-height: 21px; white-space: normal;">当然，我们不必每次都做事件源的判断工作，可以将其抽象一下交给工具类来完成。jquery中的delegate()方法就实现了该功能</p><p style="margin: 0px 0px 1.5em; padding: 0px; border: 0px; font: inherit; vertical-align: baseline; line-height: 21px; white-space: normal;">语法是这样的<code style="margin: 0px; padding: 0px; border: 0px; font-size: 0.875em; font: inherit; vertical-align: baseline; line-height: 1.75em; font-family: &amp;apos;Courier New&amp;apos;, Courier, monospace;">$(selector).delegate(childSelector,event,data,function)</code>，例如：</p><div style="margin: 0px 0px 1.5em; padding: 0px; border: 0px; font: inherit; vertical-align: baseline; line-height: 21px; white-space: normal;"><pre style="margin-top: 0px; margin-bottom: 0px; padding: 0px; border: 0px; font: inherit; vertical-align: baseline; line-height: 1.75em;">
$(&quot;div&quot;).delegate(&quot;button&quot;,&quot;click&quot;,function(){
  $(&quot;p&quot;).slideToggle();
});
</pre></div></div></div></div></span>
</div></body></html> 