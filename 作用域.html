<html>
<head>
  <title>作用域</title>
  <basefont face="Tahoma" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/274870; Windows/6.3.9600;"/>
  <style>
    body, td {
      font-family: Tahoma;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="691"/>
<h1>作用域</h1>

<div>
<span style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><div><b>变量</b></div><div><hr/></div><div>     变量是存储信息的容器。</div><div>     变量必须以字母开头</div><div>     变量也能以 $ 和 _ 符号开头（不过我们不推荐这么做）</div><div>     变量名称对大小写敏感（y 和 Y 是不同的变量）</div><div>     变量的文本值是数字不用加引号</div><div>      一条语句，多个变量 var name,age,color;</div><div>     在函数外var = name; 过后，编译的时候，会自动加上  var name = underfined;</div><div><strong>     </strong></div><div><strong>作用域</strong></div><div><hr/></div><div>     函数作用域</div><div>     块作用域</div><div>     全局作用域</div><div><strong><br/></strong></div><div><strong>变量的类型</strong></div><div><hr/></div><div>     全局变量</div><div>     局部变量     </div><div><br/></div><div>     Javascript语言的特殊之处，就在于函数内部可以直接读取全局变量<strong>。</strong></div><div>     另一方面，在函数外部自然无法读取函数内的局部变量<strong>。</strong></div><div>     函数内部声明变量的时候，一定要使用var命令<strong>。</strong>如果不用的话，你实际上声明了一个全局变量！</div><div><br/></div><div><strong>全局 JavaScript 变量</strong> </div><hr/><div>     网页上的所有脚本和函数都能访问它。</div><div><br/></div><div><strong>局部 JavaScript 变量</strong>    </div><div><hr/></div><div>  在 JavaScript 函数内部声明的变量（使用 var）是局部变量，所以只能在函数内部访问它。（该变量的作用域是局部的）。</div><div>  只要函数运行完毕，本地变量就会被删除。</div><div><br/></div><div><strong>JavaScript 变量的生存期</strong></div><div><hr/></div><div>  JavaScript 变量的生命期从它们被声明的时间开始。</div><div>  局部变量会在函数运行以后被删除。</div><div>  全局变量会在页面关闭后被删除。</div><div><br/></div><div><br/></div><div><b>Javascript语言的特殊之处，就在于函数内部可以直接读取全局变量。</b></div><div><hr/></div><div>var n=999;</div><div>　　function f1(){</div><div>　　　　alert(n);</div><div>　　}</div><div>　　f1(); // 999</div><div><br/></div><div>另一方面，在函数外部自然无法读取函数内的局部变量。</div><div><br/></div><div>　　function f1(){</div><div>　　　　var n=999;</div><div>　　}</div><div>　　alert(n); // error</div><div><br/></div><div>这里有一个地方需要注意，函数内部声明变量的时候，一定要使用var命令。如果不用的话，你实际上声明了一个全局变量！</div><div><br/></div><div>　　function f1(){</div><div>　　　　n=999;</div><div>　　}</div><div>　　f1();</div><div>　　alert(n); // 999</div><div><br/></div><div>--------------------------------------------------------------------------------------------------------</div><div><br/></div><div><strong>如何从外部读取局部变量</strong></div><div><br/></div><div>出于种种原因，我们有时候需要得到函数内的局部变量。但是，前面已经说过了，正常情况下，这是办不到的，只有通过变通方法才能实现。</div><div><br/></div><div>那就是在函数的内部，再定义一个函数。</div><div><br/></div><div>　　function f1(){</div><div><br/></div><div>　　　　n=999;</div><div><br/></div><div>　　　　function f2(){</div><div>　　　　　　alert(n); // 999</div><div>　　　　}</div><div><br/></div><div>　　}</div><div><br/></div><div>在上面的代码中，函数f2就被包括在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的。但是反过来就不行，f2内部的局部变量，对f1 就是不可见的。</div><div><br/></div><div>这就是Javascript语言特有的“<strong>链式作用域</strong>”结构（chain scope），</div><div><br/></div><div>子对象会一级一级地向上寻找所有父对象的变量。</div><div><br/></div><div>所以，父对象的所有变量，对子对象都是可见的，反之则不成立。</div><div><br/></div><div>既然f2可以读取f1中的局部变量，那么只要把f2作为返回值，我们不就可以在f1外部读取它的内部变量了吗！</div><div><br/></div><div>　　function f1(){</div><div><br/></div><div>　　　　n=999;</div><div><br/></div><div>　　　　function f2(){</div><div>　　　　　　alert(n);</div><div>　　　　}</div><div><br/></div><div>　　　　return f2;</div><div><br/></div><div>　　}</div><div>　　var result=f1();</div><div>　　result(); // 999</div><div><br/></div><div>-----------------------------------------------------------------------------------------------------------------------------------</div><div><br/></div><div><strong>Javascript作用域加深：</strong></div><div><br/></div><div>在Javascript，全局环境本身就一个对象。</div><div>在浏览器宿主中这个对象是window</div><div>言归正传，当我们写下：var i=1时，其实就是声明了一个window作用域的一个变量。</div><div>而当我们写下i=1时，是声明了一个window的属性。</div><div>看这样一段代码</div><div><br/></div><div>var a = &quot;hello&quot;;</div><div>b = &quot;world&quot;;</div><div>Test();</div><div>function Test() {</div><div>alert(a + &quot; &quot; + b);</div><div>var a = &quot;welcome&quot;;</div><div>b = &quot;china&quot;;</div><div>alert(a + &quot; &quot; + b);</div><div>}</div><div>alert(a + &quot; &quot; + b);</div><div><br/></div><div>结果是：undefined world，welcome china, hello china.</div><div><br/></div><div>在上文中，我们说过，在Javascript预编译时，会把所有var变量创建，默认值为undefined例子：</div><div>alert(a);</div><div>alert(b);</div><div>var a = &quot;111&quot;;</div><div>b = &quot;111&quot;;</div><div><br/></div><div>结果是: underfined   提示脚本错误 b is not defind</div><div><br/></div><div>由此就可以表明，a在预编译的过程中就已经被创建并且初始化为undefined，而b却只能在实际运行时按顺序去解释。其实在预编译后的Javascript代码可以近乎理解如下：</div><div><br/></div><div>var a = undefined;</div><div>alert(a);</div><div>alert(b);</div><div>a = &quot;111&quot;;</div><div>b = &quot;111&quot;;</div><div><br/></div><div><strong>每当代码运行进入一个函数时</strong></div><div><br/></div><div>Javascript引擎就会自动创建一个新的作用域，然后把这个新作用域作为当前作用域的子作用域，然后把当前的代码作用域切换到这个新作用域。当代码退出函数时，这个作用域销毁，把代码作用域交还给他的父作用域。</div><div><br/></div><div>首先代码进行在预编译，当进入 Test方法时，开启一个新作用域，然后把全局作用域作为他的父作用域。然后对Test内的方法进行预编译，和上面的代码一样，Test方法被预编译后方法体大致如下：</div><div><br/></div><div>function Test() {</div><div>var a = undefined;</div><div>alert(a + &quot; &quot; + b);</div><div>var a = &quot;welcome&quot;;</div><div>b = &quot;china&quot;;</div><div>alert(a + &quot; &quot; + b);</div><div><br/></div><div>当然，在当前作用域下无法找到b，于是他就会到他的父作用域下，也就是全局作用域找到了b=“world”。于是也就产生了这样的结果。</div><div><br/></div><div>//</div><div>//</div><div>函数内部带 var 声明变量 会形成一个作用域 , 这个变量会被定义到该作用域中 , 所以该函数执行完毕后 , 变量也会随之销毁 , 而在外层作用域中则无法访问到该变量</div><div>var foo = function(){</div><div>     var load = {}</div><div>}</div><div>foo()</div><div>console.log( load ) ==&gt; Undefined</div><div><br/></div><div>函数内部如果并没有使用 var 声明变量的话 该变量会被 作为 全局变量来定义 故 外层 作用域可以访问 到这个变量</div><div>var foo = function(){</div><div>     load = {}</div><div>     // 等效于 global.load = {},</div><div>}</div><div>foo()</div><div>console.log( load ) ==&gt; Object{}</div><div><b><br/></b></div><div><b>作用域链</b></div><div>多层函数嵌套 场景  --  典型的作用域链</div><div><br/></div><div>function foo() {<br/>
  var val = 'hello';<br/><br/>
  function bar() {<br/>
    function baz() {<br/>
      global.val = 'world;'<br/>
    }<br/>
    baz();<br/>
    console.log(val); //=&gt; hello<br/>
  }<br/>
  bar();<br/>
}<br/>
foo(); ==&gt; hello</div><div><br/></div><div>由於 JavaScript 中，變量標識符的查找是從當前作用域開始向外查找</div><div>直到全局作用域為止。所以 JavaScript 代碼中對變量的訪問只能向外進行，而不能逆而行之。<br/><br/>
baz()函數的執行在全局作用域中定義了一個全局變量val</div><div>而在bar()函數中，對val這一標識符進行訪問時，按照從內到外厄德查找原則：</div><div>在bar函數的作用域中沒有找到，便到上一層，即foo()函數的作用域中查找。<br/>
然而，使大家產生疑惑的關鍵就在這裡：</div><div>本次標識符訪問在foo()函數的作用域中找到了符合的變量，</div><div>便不會繼續向外查找，故在baz()函數中定義的全局變量val並沒有在本次變量訪問中產生影響。</div><div><br/></div><div><hr/></div><div>var x = 10;</div><div>var foo = {</div><div>  x: 20,</div><div>  bar: function(){</div><div>    var x = 30;</div><div>    return this.x;</div><div>  }</div><div>};</div><div><br/></div><div>(foo.bar)();</div><div>-&gt; 20</div><div>// 括号不影响表达式的值,相当于 直接调用 foo.bar();</div><div><br/></div><div>(foo.bar = foo.bar)();</div><div>-&gt; 10</div><div>//括号表达式返回赋值操作的结果, 也就是foo的成员bar函数, 而调用的时候已经回到了全局作用域</div><div><br/></div><div>(foo.bar,  foo.bar)();</div><div>//与上式相同,都是返回表达式的结果,也就是后面的bar函数,同样相当于在全局作用域调用bar函数</div><div>-&gt;10</div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></span>
</div></body></html> 